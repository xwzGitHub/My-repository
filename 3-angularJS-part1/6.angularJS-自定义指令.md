# angular 自定义指令

    1. 指令可以是一个模板  (用来提取多次复用的dom结构[html] 我们称之为 组件)

    2. 也可是一个功能 (用来提取多次复用的 function[js] )

    3. api
```javascript
        angular.module('app',[])
               .directive('directive',[function(){
                    return{  //返回 object 或者 function
                            restrict:'ECMA',
                            replace:true,
                            priority:1,//默认是0 优先级越高 越先执行
                            terminal:true, //默认false 如果设置为true 则会阻止比该指令优先级低的指令执行
                            transclude:true, //默认是false //如果是true 并且 template 里边 含有ng-transclude 指令 那么父元素的内容将会被保存在 含有ng-transclude指令的元素内。
                            template:'<div>自定义指令</div>',
                            scope:{
                                a:'=',
                                b:'@',
                                c:'&'
                            },
                            controller:[function(){

                            }],
                            controllerAs:'controllerName',
                            require:'?^ngModel', // require 属性能获取 绑定了 ngModel的元素的控制器并在link 函数的第四个参数中传入
                            link:function(scope,element,attribue,ngModelController){

                            },
                            compile:function(){
                                return {
                                    pre:function(scope,element,attribue){

                                    },
                                    post:function(scope,element,attribue){

                                    }
                                }
                            }
                    }
               }])
```
## replace

    默认是false

    如果为true 将替换掉该指令所在的元素

## restrict

    type : string

    E element         <directivename></directivename>   
    C class           <tagname class='directivename'><tagname>
    M 注释             <!-- directive: directivename -->  1. replace true 2.按格式
    A attribute        <tagname directivename></tagname>  例子: <div directivename></div>

## template

    type : string / function

    string : '<div>自定义指令</div>'  (html 元素模板 一个字符串)
```js
function : function($element,$attributes){  //必须在 replace 为false 的时候使用

}
```
## templateUrl

    type : string / function

    string : './directive.html'    (html 元素模板 一个单独的html文件)
```js
function : function($element,$attributes){  //必须在 replace 为false 的时候使用

}
```
## priority

    默认是0 优先级越高 越先执行

## terminal

    默认false 如果设置为true 则会阻止比该指令优先级低的指令执行

## transclude

    默认是false 
    
    如果是true 并且 template 里边 含有ng-transclude 指令,
    
    那么父元素的内容将会被保存在 含有ng-transclude指令的元素内。

## scope

    scope 默认值是 false

    scope : boolean / object

    如果是   false 那么 将不新建自己的scope 使用 父元素的scope
    如果是   true  那么 新建自己的scope 并且继承 父级的scope

    如果是对象 那么新建自己的scope 并且 按你的意思来集成父元素的scope的某些属性或者一个都不继承 或者 单向绑定 或者 双向绑定
    
    {
        a:'=',     // =  是双向绑定的意思
        b:'@'      // @  是单向绑定的意思
        c:'&'      // &  传递function的  传递的时候需要 调用一下 然后呢 使用的时候也要调用一下
    }

    使用'='时如何传递值 <directivename a="data"></directivename> 

    使用'@' 时如何传递值 <directivename b="{{data}}"></directivename>  使用b="data" 会把 data 识别为字符串

    使用'&' 时如何传递值 <directivename c="fn()"></directivename> 
    
## require
    require 属性能获取 绑定了 ngModel的元素的控制器并在link 函数的第四个参数中传入

    在自定义指令中通常会出先一些通用的代码逻辑 为了不违反 DRY 原则 可以把这些逻辑写在同一个指令的控制器上

    然后通过require 来获取

    用法 require:'?^directiveName'

    其中? 号表示 如果这个指令没有被找到 那么 将会传递一个 null 给link 的第四个参数 而不是undefined

        ^ 号表示 将会在本身和父指令上查找这个指令

    不加任何修饰符表示只在指令本身查找被require的指令

    DRY(Don't repeat your self) 原则 

    在编码过程中不要出现重复代码，也就是要写出高复用，低耦合的代码。
## compile

    他和link 的功能相似 但是 更加强大和复杂

    compile 顾名思义 是编译dom的

    就是说 我们含有angular指令的dom 不能直接绑定到 dom 数上去


    他有三个阶段

        1. 预编译  return 之前

        2. prelink 就是说当他在编译自己的时候触发的 如果在这个过程中 他发现了子指令那么接下来会运行子指令的 prelink 如此一直进行到最后一个子指令 pre 阶段完成

        3. 当prelink 完成之后 会 从最后一个子指令的 postlink开始执行 让后依次向上执行postlink 直到 最大的父指令 完成 postlink 此时compile 结束 (可以在即将结束之前 把postlink当作 link 使用 故 link被屏蔽)
        

## link

    他提供了一个 修改dom的机会 在dom绑定到 dom树 之前

    function(scope,element,attribute){

    }

    //compile 存在的时候会被屏蔽

## controllerAs

    给匿名控制器命名

    可以将数据挂载在这个别名上 再改控制器里面通过 this.attribute = $scope.data 来挂载



## demo1
```js
.directive('ngPlaceholder',function(){
                return function($scope,$element,$attributes){
                    var value = $attributes['ngPlaceholder']
                    var valueStr = '$scope.'+value;
                    $element[0].placeholder = eval(valueStr)
                }
           })
```
```html
<div ng-repeat="value in ['账号','密码','确认密码']">
    <input ng-placeholder="value" />
</div>
```

## demo2
```js
.directive('getElement',[function(){
                return function($scope,$element,$attributes){
                    $scope[$attributes['getElement']] = $element
                }
            }])
```